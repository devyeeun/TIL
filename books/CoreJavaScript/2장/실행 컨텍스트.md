# 코어자바스크립트(위키북스)


## 2장 - 실행 컨텍스트
실행 컨텍스트는 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**로, 자바스크립트 코드가 실행되는 환경을 의미한다.  
자바스크립트의 동작 언어로서의 성격을 가장 잘 파악할 수 있는 개념.

### 스택과 큐
> - 스택 : 출입구가 하나뿐인 깊은 우물같은 데이터구조 LIFO 
> - 큐 : 양쪽이 모두 열려있는 파이프 같은 구조 FIFO


1. 스택 :   
스택에 순서대로 데이터 a, b, c, d를 저장했다면, 꺼낼때는 반대로 d, c, b, a 순서로 꺼낸다. 스택이 넘치면 에러를 던진다.

2. 큐 :   
양쪽 모두 입, 출력이 가능한 큐도 있지만 보통은 한쪽은 입력만, 다른 한쪽은 출력만을 담당한다. 순서대로 데이터 a, b, c, d를 저장했다면, 꺼낼때도 a, b, c, d 순서로 꺼낸다.

<br/>

### 실행 컨텍스트

하나의 실행 컨텍스트를 구성할 수 있는 방법으로 크게 3가지가 있다.
> 1. 전역 코드
> 2. 함수 코드
> 3. eval 함수

<br/>

전역 컨텍스트라는 개념은 **코드가 실행되기 전에 생성되는 컨텍스트**로, 전역 컨텍스트는 하나만 존재한다.  
최상단의 공간은 코드 내부에서 별도의 실행 명령이 없어도 브라우저에서 자동으로 실행하므로 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 된다.

한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점.

<br/>

실행컨텍스트는 ***VariableEnvironment***, ***LexicalEnvironment***, ***ThisBinding*** 이라는 3가지 객체를 가지고 있다.

### VariableEnvironment
실행 컨텍스트가 생성될 때 현재 컨텍스트 내의 식별자들에 대한 정보를 담는 객체.  
LexicalEnvironment와 담기는 내용은 같지만, LexicalEnvironment는 함수 실행 도중에 변경되는 사항이 즉시 반영되는 반면, VariableEnvironment는 초기 상태를 유지한다.

실행 컨텍스트를 생성할 때, VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용한다.

VariableEnvironment와 LexicalEnvironment의 내부는 environmentRecord와 outereEnvironmentReference로 구성되어 있다.
<br/><br/>


### LexicalEnvironment
실제로 식별자와 바인딩된 값을 관리하는 객체
'현재 컨텍스트의 내부에는 어떤 식별자들이 있고, 그 외부 정보는 00을 참조하도록 구성되어있다.' 라는 느낌으로 모아놓은 것이다.


#### environmentRecord와 호이스팅
environmentRecordㅇ에는 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.  
컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당한다.  
컨텍스트 낸부 전체를 처음부터 끝까지 쭉 훑어나가며 **순서대로** 수집한다.

> 전역 실행 컨텍스트는 자바스크립트 구동환경이 별도로 제공하는 객체, 즉 전역 객체를 활용한다.


<br/><br/>
변수 정보를 수집하는 과정을 모두 마쳤더라도, 아직 실행 컨텍스트가 관여할 코드들은 실행되기 전의 상태이다.
코드가 실행되기 전에, 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 알고 있게 되는 것이다.

#### 호이스팅

흔히 호이스팅 개념을 '자바스크립트 엔진이 식별자들을 최상단으로 끌어올린 다음 코드를 실행한다' 로 설명하는데, 실제로 자바스크립트 엔진이 끌어올리지는 않지만, 편의상 끌어올린 것으로 간주한 가상의 개념이다.
(environment record의 수집 과정을 추상화한 개념이다.)
> 즉, 호이스팅은 함수나 변수의 선언이 마치 위로 끌려올려진 것처럼 동작하는 것

<br/>

##### 호이스팅 규칙
environmentRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담긴다.

```javascript
function a(x) {
	console.log(x); 
    var x
    console.log(x);
    var x = 2 
    console.log(x);
}

a(1);
```
호이스팅이 되지 않았을 때, 위의 예시가 어떤 값이 출력될지 예상해보자.
첫 번째 x는 함수 호출시 전달된 1이 출력되고, 두 번째에는 선언된 변수에 할당된 값이 없으므로 undefined가 출력되고, 마지막에는 2가 할당될 것 같다.

실제로는 어떨까?

이해하기 쉽게 코드를 바꿔보자.

```javascript
function a(){
    var x = 1;
    console.log(x); 	
    var x;
    console.log(x);
    var x = 2;
    console.log(x);
}

a();
```

environmentRecord는 현재 실행될 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 관심이 있다.   
각 식별자에 어떤 값이 할당될 것인지는 관심이 없다.  
변수를 호이스팅할 때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다.

```javascript
function a(){
    var x;
    var x;
    var x;
    
    x = 1;
    console.log(x); 	
    console.log(x);
    x = 2;
    console.log(x);
}

a();
```
이후 실제 코드를 출력하면, 1,1,2 가 나온다.

```javascript
function abc(){
	console.log(b); 
    var b = 'bbb'
    console.log(b);
    function b(){}
    console.log(b);
}

abc();
```
출력 결과를 예측해보면 처음엔 b가 없으니 undefined, 두번째는 'bbb', 세번째는 함수 b가 출력될 것 같다.
실제로는?

a함수를 실행한 순간 a함수의 실행 컨텍스트가 생성된다.
이때 호이스팅이 일어나 변수명과 함수 선언의 정보가 위로 끌어올려져 다음과 같은 형태로 변화한다.

변수는 선언부와 할당부를 나누어 선언부만 끌어올리지만 함수 선언은 함수 전체를 끌어올린다.  
호이스팅이 끝난 상태에서의 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것으로 여길 수 있다.

```javascript
function abc(){
    var b;
    var b = function b(){}  // 함수명으로 선언한 변수에 함수 할당
	console.log(b); 
    b = 'bbb'
    console.log(b);
    console.log(b);
}

abc();
```
그렇게 되면, 출력은 처음 b함수, bbb, bbb 순으로 출력되는 것을 확인할 수 있다.